# bot_futures.py
from __future__ import annotations
import asyncio, json, os
from dataclasses import dataclass
from typing import Optional, List

import pandas as pd
from telegram import Update
from telegram.ext import Application, CommandHandler, ContextTypes

from config import CFG
from fdata_providers import FuturesPriceProvider
from trade_binance_futures import BinanceFuturesREST
from fscanner import fut_best_symbols, fut_format
from fstrategy import CombinedStrategy
from charting import plot_hourly_with_targets
from utils import now_local

# ------------- ÿ•ÿπÿØÿßÿØÿßÿ™ ŸÖŸÜ .env -------------
FUT_TP = float(CFG.get("FUT_TP_PCT", 0.10))
FUT_SL = float(CFG.get("FUT_SL_PCT", 0.02))
FUT_TRAIL = float(CFG.get("FUT_TRAIL_PCT", 0.02))
FUT_COOLDOWN = int(CFG.get("FUT_COOLDOWN_S", 60))

FUT_AUTOSCAN = bool(int(str(CFG.get("FUT_AUTOSCAN", 1))))
FUT_SCAN_MIN = int(CFG.get("FUT_SCAN_INTERVAL_MIN", 60))
FUT_MIN_QVOL = float(CFG.get("FUT_MIN_QVOL_USD", 5_000_000))

FUT_ORDER_MODE = str(CFG.get("FUT_ORDER_MODE", "ALL")).upper()  # ALL / FIXED
FUT_ORDER_USDT = float(CFG.get("FUT_ORDER_USDT", 25))

FUT_DEFAULT_LEV = int(CFG.get("FUT_LEVERAGE", 10))
FUT_DEFAULT_MARGIN = str(CFG.get("FUT_MARGIN_TYPE", "ISOLATED")).upper()  # ISOLATED/CROSSED
FUT_SYMBOL = str(CFG.get("FUT_SYMBOL", "BTCUSDT")).upper()

# ÿÆÿ±Ÿäÿ∑ÿ© ÿ±ÿßŸÅÿπÿ© ŸÑŸÉŸÑ ÿ±ŸÖÿ≤: ŸÖŸÜ .env (ŸÖÿ´ÿßŸÑ: BTCUSDT:15,ETHUSDT:10)
def _parse_lev_map(s: str | None) -> dict:
    out = {}
    if not s:
        return out
    for part in str(s).split(","):
        if ":" in part:
            sym, x = part.split(":", 1)
            sym = sym.strip().upper()
            try:
                out[sym] = int(x.strip())
            except:
                pass
    return out

FUT_LEV_MAP = _parse_lev_map(CFG.get("FUT_LEVERAGE_MAP"))

ADMIN_ID = int(CFG.get("TELEGRAM_ADMIN", CFG.get("TELEGRAM_ADMIN_ID", 0)) or 0)

# ------------- ŸÉÿßÿ¶ŸÜÿßÿ™ -------------
fbr = BinanceFuturesREST(
    api_key=CFG["BINANCE_API_KEY"],
    api_secret=CFG["BINANCE_API_SECRET"],
    testnet=bool(int(str(CFG.get("BINANCE_TESTNET", 0)))),
    timeout=15,
)
strat = CombinedStrategy(min_votes=int(CFG.get("FUT_MIN_VOTES", 2)))

TRADING_ON = False
CURRENT = FUT_SYMBOL
LAST_KLINES: Optional[pd.DataFrame] = None
LAST_MIN: Optional[int] = None
LAST_SCAN_AT: Optional[pd.Timestamp] = None
LAST_BEST = []
LAST_TRADE_TS = now_local() - pd.Timedelta(seconds=FUT_COOLDOWN)

LEV_FILE = "fut_lev_map.json"

@dataclass
class FPos:
    symbol: str
    is_long: bool   # True: LONG, False: SHORT
    entry: float
    qty: float
    sl: float
    extreme: float   # ÿ£ÿπŸÑŸâ ŸÇŸÖÿ© ŸÖŸÜÿ∞ ÿßŸÑÿØÿÆŸàŸÑ ŸÑŸà LONGÿå ÿ£ÿØŸÜŸâ ŸÇÿßÿπ ŸÑŸà SHORT
    entry_ts: pd.Timestamp
    fast: bool = False

OPEN: Optional[FPos] = None

# ------------- ÿ±ÿßŸÅÿπÿ© ŸÑŸÉŸÑ ÿ±ŸÖÿ≤ (ÿ≠ŸÅÿ∏/ÿ™ÿ≠ŸÖŸäŸÑ) -------------
def _load_lev() -> dict:
    # ÿ™ÿ±ÿ™Ÿäÿ® ÿßŸÑÿ£ŸàŸÑŸàŸäÿ©: JSON ŸÖÿ≠ŸÅŸàÿ∏ -> ŸÖŸÜ .env FUT_LEVERAGE_MAP -> ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä
    try:
        if os.path.exists(LEV_FILE):
            with open(LEV_FILE, "r", encoding="utf-8") as f:
                d = json.load(f)
                return {k.upper(): int(v) for k, v in d.items()}
    except Exception:
        pass
    return {**FUT_LEV_MAP}

def _save_lev(d: dict):
    try:
        with open(LEV_FILE, "w", encoding="utf-8") as f:
            json.dump({k.upper(): int(v) for k, v in d.items()}, f, ensure_ascii=False, indent=2)
    except Exception:
        pass

LEV_MAP = _load_lev()

def _symbol_lev(symbol: str) -> int:
    return int(LEV_MAP.get(symbol.upper(), FUT_DEFAULT_LEV))

# ------------- ÿµŸÑÿßÿ≠Ÿäÿßÿ™ -------------
def _is_admin(update: Update) -> bool:
    u = update.effective_user
    if not u:
        return False
    if ADMIN_ID and u.id == ADMIN_ID:
        return True
    uname_env = (CFG.get("TELEGRAM_ADMIN_USERNAME") or "").lstrip("@").lower()
    return bool(uname_env and (u.username or "").lower() == uname_env)

# ------------- ÿ£ÿØŸàÿßÿ™ -------------
async def _fetch_1m(symbol: str):
    prov = FuturesPriceProvider()
    df = await asyncio.to_thread(prov.get_recent_1m, symbol, 900)
    return df, (prov.last_symbol or symbol)

def _order_quote_budget() -> float:
    if FUT_ORDER_MODE == "FIXED":
        return max(5.0, FUT_ORDER_USDT)
    # ALL: ŸÉÿßŸÖŸÑ ÿßŸÑÿ±ÿµŸäÿØ ÿßŸÑŸÖÿ™ÿßÿ≠
    try:
        bal = float(fbr.get_free_usdt())
    except Exception:
        bal = 0.0
    return max(5.0, bal)

# ------------- AutoScan -------------
async def autoscan_tick(context: ContextTypes.DEFAULT_TYPE):
    global LAST_SCAN_AT, LAST_BEST, CURRENT
    if not FUT_AUTOSCAN:
        return
    if LAST_SCAN_AT and (now_local() - LAST_SCAN_AT).total_seconds() < FUT_SCAN_MIN*60:
        return
    try:
        cands = fut_best_symbols(fbr, min_qv_usd=FUT_MIN_QVOL, limit=20)
        LAST_BEST = cands[:5]
        LAST_SCAN_AT = now_local()
        if OPEN is None and cands:
            top = cands[0].symbol
            if top != CURRENT:
                old = CURRENT
                CURRENT = top
                await context.bot.send_message(chat_id=ADMIN_ID, text=f"üîé Futures AutoScan: {old} ‚Üí {CURRENT}")
    except Exception as e:
        await context.bot.send_message(chat_id=ADMIN_ID, text=f"‚ö†Ô∏è Futures AutoScan ŸÅÿ¥ŸÑ: {e}")

# ------------- ÿßŸÑÿ™ÿØÿßŸàŸÑ ÿßŸÑÿØŸàÿ±Ÿä -------------
async def trade_tick(context: ContextTypes.DEFAULT_TYPE):
    global LAST_KLINES, LAST_MIN, OPEN, LAST_TRADE_TS, TRADING_ON

    if not TRADING_ON:
        return

    symbol = OPEN.symbol if OPEN else CURRENT

    # ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ¥ŸÖŸàÿπ ŸÖÿ±Ÿëÿ© ÿ®ÿßŸÑÿØŸÇŸäŸÇÿ©
    cur_min = now_local().minute
    if LAST_KLINES is None or cur_min != LAST_MIN:
        try:
            df, _ = await _fetch_1m(symbol)
            if df is not None and not df.empty:
                LAST_KLINES, LAST_MIN = df, cur_min
        except Exception as e:
            await context.bot.send_message(chat_id=ADMIN_ID, text=f"‚ö†Ô∏è ÿ™ÿπÿ∞Ÿëÿ± ÿ™ÿ≠ÿØŸäÿ´ ÿ¥ŸÖŸàÿπ Futures: {e}")
            return

    if LAST_KLINES is None or LAST_KLINES.empty:
        return

    df = LAST_KLINES
    close = df["Close"].astype(float)
    price = float(close.iloc[-1])

    # ÿ•ÿØÿßÿ±ÿ© ÿßŸÑŸÖÿ±ŸÉÿ≤ ÿßŸÑŸÖŸÅÿ™Ÿàÿ≠
    if OPEN:
        if OPEN.is_long:
            # ÿ≠ÿØ ÿ£ÿπŸÑŸâ ŸÖŸÜÿ∞ ÿßŸÑÿØÿÆŸàŸÑ
            if price > OPEN.extreme:
                OPEN.extreme = price
            hit_tp = price >= OPEN.entry * (1 + FUT_TP)

            # Fast-runner: ŸÇŸÅŸÑ ÿ±ÿ®ÿ≠ ŸÖÿ®ŸÉÿ± + ÿ™ÿ±ŸäŸÑ
            if hit_tp and not OPEN.fast:
                OPEN.fast = True
                lock = OPEN.entry * (1 + FUT_TP * 0.8)
                if lock > OPEN.sl:
                    OPEN.sl = lock
                await context.bot.send_message(chat_id=ADMIN_ID, text=f"üèÉ‚Äç‚ôÇÔ∏è Fast-runner LONG ‚Äî SL‚â•{OPEN.sl:.6f}")

            if OPEN.fast:
                trail = OPEN.extreme * (1 - max(0.0, FUT_TRAIL))
                OPEN.sl = max(OPEN.sl, trail, OPEN.entry * (1 + FUT_TP * 0.5))

            # ÿÆÿ±Ÿàÿ¨
            if price <= OPEN.sl:
                try:
                    fbr.close_all_for_symbol(OPEN.symbol)
                    await context.bot.send_message(chat_id=ADMIN_ID, text=f"üîî ÿÆÿ±Ÿàÿ¨ SL LONG {OPEN.symbol} @ {price:.6f}")
                except Exception as e:
                    await context.bot.send_message(chat_id=ADMIN_ID, text=f"‚ö†Ô∏è ŸÅÿ¥ŸÑ ÿ•ÿ∫ŸÑÿßŸÇ SL LONG: {e}")
                OPEN = None
                LAST_TRADE_TS = now_local()
                return

            if hit_tp and not OPEN.fast:
                try:
                    fbr.close_all_for_symbol(OPEN.symbol)
                    await context.bot.send_message(chat_id=ADMIN_ID, text=f"‚úÖ TP LONG {OPEN.symbol} @ {price:.6f}")
                except Exception as e:
                    await context.bot.send_message(chat_id=ADMIN_ID, text=f"‚ö†Ô∏è ŸÅÿ¥ŸÑ ÿ•ÿ∫ŸÑÿßŸÇ TP LONG: {e}")
                OPEN = None
                LAST_TRADE_TS = now_local()
                return

        else:
            # SHORT: ÿ£ÿØŸÜŸâ ŸÇÿßÿπ ŸÖŸÜÿ∞ ÿßŸÑÿØÿÆŸàŸÑ
            if price < OPEN.extreme:
                OPEN.extreme = price
            hit_tp = price <= OPEN.entry * (1 - FUT_TP)

            if hit_tp and not OPEN.fast:
                OPEN.fast = True
                # ŸÇŸÅŸÑ ÿ±ÿ®ÿ≠ ÿ™ÿ≠ÿ™ ÿßŸÑÿØÿÆŸàŸÑ
                lock = OPEN.entry * (1 - FUT_TP * 0.8)
                if lock < OPEN.sl:
                    OPEN.sl = lock
                await context.bot.send_message(chat_id=ADMIN_ID, text=f"üèÉ‚Äç‚ôÇÔ∏è Fast-runner SHORT ‚Äî SL‚â§{OPEN.sl:.6f}")

            if OPEN.fast:
                # ÿ™ÿ±ŸäŸÑ ŸÑŸÑŸÄ SHORT: ÿ£ÿπŸÑŸâ ŸÖŸÜ ÿ£ÿØŸÜŸâ ŸÇÿßÿπ ÿ®ŸÜÿ≥ÿ®ÿ©
                trail = OPEN.extreme * (1 + max(0.0, FUT_TRAIL))
                # ÿ®ÿßŸÑŸÜÿ≥ÿ®ÿ© ŸÑŸÑŸÄ SHORTÿå ŸÜŸÇŸÑŸëŸÑ ÿßŸÑŸÄ SL ŸÑŸÑÿ£ÿ≥ŸÅŸÑ (ŸÇŸäŸÖÿ© ÿ£ÿµÿ∫ÿ±) ŸÑÿ≠ÿ¨ÿ≤ ÿ±ÿ®ÿ≠
                OPEN.sl = min(OPEN.sl, trail, OPEN.entry * (1 - FUT_TP * 0.5))

            # ÿÆÿ±Ÿàÿ¨
            if price >= OPEN.sl:
                try:
                    fbr.close_all_for_symbol(OPEN.symbol)
                    await context.bot.send_message(chat_id=ADMIN_ID, text=f"üîî ÿÆÿ±Ÿàÿ¨ SL SHORT {OPEN.symbol} @ {price:.6f}")
                except Exception as e:
                    await context.bot.send_message(chat_id=ADMIN_ID, text=f"‚ö†Ô∏è ŸÅÿ¥ŸÑ ÿ•ÿ∫ŸÑÿßŸÇ SL SHORT: {e}")
                OPEN = None
                LAST_TRADE_TS = now_local()
                return

            if hit_tp and not OPEN.fast:
                try:
                    fbr.close_all_for_symbol(OPEN.symbol)
                    await context.bot.send_message(chat_id=ADMIN_ID, text=f"‚úÖ TP SHORT {OPEN.symbol} @ {price:.6f}")
                except Exception as e:
                    await context.bot.send_message(chat_id=ADMIN_ID, text=f"‚ö†Ô∏è ŸÅÿ¥ŸÑ ÿ•ÿ∫ŸÑÿßŸÇ TP SHORT: {e}")
                OPEN = None
                LAST_TRADE_TS = now_local()
                return

    # ÿ™ÿ®ÿ±ŸäÿØ
    if (now_local() - LAST_TRADE_TS).total_seconds() < FUT_COOLDOWN:
        return

    # ÿØÿÆŸàŸÑ ÿ¨ÿØŸäÿØ
    if OPEN is None:
        df, _ = await _fetch_1m(CURRENT)
        if df is None or df.empty:
            return

        # ŸÇÿ±ÿßÿ± ŸÖŸÜ ÿßŸÑÿ•ÿ≥ÿ™ÿ±ÿßÿ™Ÿäÿ¨Ÿäÿ© ÿßŸÑŸÖÿ¨ŸÖŸëÿπÿ©
        d = strat.decide(df)
        signal = d.signal

        if signal in ("LONG", "SHORT"):
            # ÿßÿ∂ÿ®ÿ∑ ÿßŸÑÿ±ÿßŸÅÿπÿ© ŸàÿßŸÑŸÜŸàÿπ
            try:
                fbr.set_margin_type(CURRENT, FUT_DEFAULT_MARGIN)
            except Exception:
                pass
            try:
                fbr.set_leverage(CURRENT, _symbol_lev(CURRENT))
            except Exception:
                pass

            usdt = _order_quote_budget()
            if usdt < 5.0:
                await context.bot.send_message(chat_id=ADMIN_ID, text=f"‚ö†Ô∏è Futures: ÿ±ÿµŸäÿØ ÿ∫Ÿäÿ± ŸÉÿßŸÅŸç. USDT={usdt:.2f}")
                return

            px = float(df["Close"].iloc[-1])
            try:
                if signal == "LONG":
                    od = fbr.order_market_quote_notional(CURRENT, "BUY", usdt, _symbol_lev(CURRENT), mark_price=px)
                    notional = usdt * _symbol_lev(CURRENT)
                    qty_est = (notional / px) if px > 0 else 0.0
                    sl = px * (1 - FUT_SL)
                    OPEN = FPos(symbol=CURRENT, is_long=True, entry=px, qty=qty_est, sl=sl, extreme=px, entry_ts=now_local(), fast=False)
                    await context.bot.send_message(chat_id=ADMIN_ID,
                        text=f"üì• LONG {CURRENT} Lev x{_symbol_lev(CURRENT)} | Notional‚âà{notional:.2f} | Entry‚âà{px:.6f} | SL‚âà{sl:.6f}\n" +
                             "ÿõ ".join(d.reasons[-3:]))
                else:
                    od = fbr.order_market_quote_notional(CURRENT, "SELL", usdt, _symbol_lev(CURRENT), mark_price=px)
                    notional = usdt * _symbol_lev(CURRENT)
                    qty_est = (notional / px) if px > 0 else 0.0
                    sl = px * (1 + FUT_SL)
                    OPEN = FPos(symbol=CURRENT, is_long=False, entry=px, qty=qty_est, sl=sl, extreme=px, entry_ts=now_local(), fast=False)
                    await context.bot.send_message(chat_id=ADMIN_ID,
                        text=f"üì• SHORT {CURRENT} Lev x{_symbol_lev(CURRENT)} | Notional‚âà{notional:.2f} | Entry‚âà{px:.6f} | SL‚âà{sl:.6f}\n" +
                             "ÿõ ".join(d.reasons[-3:]))
                LAST_TRADE_TS = now_local()
            except Exception as e:
                await context.bot.send_message(chat_id=ADMIN_ID, text=f"‚ö†Ô∏è ŸÅÿ¥ŸÑ ŸÅÿ™ÿ≠ ŸÖÿ±ŸÉÿ≤ Futures: {e}")

# ------------- ÿ£ŸàÿßŸÖÿ± ÿ™ŸäŸÑŸäÿ¨ÿ±ÿßŸÖ -------------
async def fstart(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "ŸÖÿ±ÿ≠ÿ®ÿßŸã üëã\n\n"
        "ÿ®Ÿàÿ™ Binance USDT-M Futures (LONG/SHORT) ‚Äî ÿ•ÿ≥ÿ™ÿ±ÿßÿ™Ÿäÿ¨Ÿäÿßÿ™ ŸÖÿ¨ŸÖŸëÿπÿ© + ÿ±ÿßŸÅÿπÿ© ŸÑŸÉŸÑ ÿ±ŸÖÿ≤.\n"
        "ÿßŸÑÿ£ŸàÿßŸÖÿ±:\n"
        "/fgo ‚Äî ÿ™ÿ¥ÿ∫ŸäŸÑ (ÿ£ÿØŸÖŸÜ)\n"
        "/fstop ‚Äî ÿ•ŸäŸÇÿßŸÅ (ÿ£ÿØŸÖŸÜ)\n"
        "/fstatus ‚Äî ÿßŸÑÿ≠ÿßŸÑÿ© + ÿßŸÑÿ±ÿµŸäÿØ\n"
        "/fchart ‚Äî ÿ¥ÿßÿ±ÿ™ ÿ≥ÿßÿπÿ©\n"
        "/fbest ‚Äî ÿ£ŸÅÿ∂ŸÑ ÿßŸÑŸÖÿ±ÿ¥ÿ≠ŸäŸÜ\n"
        "/fpositions ‚Äî ÿßŸÑŸÖÿ±ÿßŸÉÿ≤ ÿßŸÑŸÖŸÅÿ™Ÿàÿ≠ÿ©\n"
        "/fclose ‚Äî ÿ•ÿ∫ŸÑÿßŸÇ ŸÖÿ±ŸÉÿ≤ ÿßŸÑÿ±ŸÖÿ≤ ÿßŸÑÿ≠ÿßŸÑŸä\n"
        "/fautoscan ‚Äî ÿ≠ÿßŸÑÿ© AutoScan\n"
        "/flev ‚Äî ÿπÿ±ÿ∂ ÿÆÿ±ÿßÿ¶ÿ∑ ÿßŸÑÿ±ÿßŸÅÿπÿ©\n"
        "/fsetlev <SYMBOL> <X> ‚Äî ÿ™ÿπŸäŸäŸÜ ÿ±ÿßŸÅÿπÿ© Ÿàÿ≠ŸÅÿ∏Ÿáÿß"
    )

async def fgo(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    if not _is_admin(update): return await update.message.reply_text("üö´ ŸÑŸÑÿ£ÿØŸÖŸÜ ŸÅŸÇÿ∑.")
    global TRADING_ON; TRADING_ON = True
    await update.message.reply_text("‚ñ∂Ô∏è ÿ™ŸÖ ÿ™ÿ¥ÿ∫ŸäŸÑ ÿ™ÿØÿßŸàŸÑ Futures.")

async def fstop(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    if not _is_admin(update): return await update.message.reply_text("üö´ ŸÑŸÑÿ£ÿØŸÖŸÜ ŸÅŸÇÿ∑.")
    global TRADING_ON; TRADING_ON = False
    await update.message.reply_text("‚èπÔ∏è ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ ÿ™ÿØÿßŸàŸÑ Futures.")

async def fstatus(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    bal = 0.0
    try: bal = float(fbr.get_free_usdt())
    except Exception: pass
    sym = OPEN.symbol if OPEN else CURRENT
    df, _ = await _fetch_1m(sym)
    last = float(df["Close"].iloc[-1]) if (df is not None and not df.empty) else 0.0
    pos_line = "ŸÑÿß ŸäŸàÿ¨ÿØ" if OPEN is None else (
        f"{OPEN.symbol} | {'LONG' if OPEN.is_long else 'SHORT'} | Qty‚âà{OPEN.qty:.6f} | Entry‚âà{OPEN.entry:.6f} "
        f"| SL‚âà{OPEN.sl:.6f} | Extreme‚âà{OPEN.extreme:.6f} | Fast={OPEN.fast}"
    )
    await update.message.reply_text(
        f"‚è± {now_local():%Y-%m-%d %H:%M} ({CFG['TZ']})\n"
        f"üí± ÿßŸÑÿ±ŸÖÿ≤ ÿßŸÑÿ≠ÿßŸÑŸä: {sym} (Lev x{_symbol_lev(sym)})\n"
        f"üìà ÿßŸÑÿ≥ÿπÿ±: {last:.6f}\n"
        f"üí∞ Futures Free USDT: {bal:.2f}\n"
        f"ü§ñ ÿßŸÑÿ™ÿØÿßŸàŸÑ: {'ŸÜÿ¥ÿ∑' if TRADING_ON else 'ŸÖÿ™ŸàŸÇŸÅ'} | üîé AutoScan: {'ON' if FUT_AUTOSCAN else 'OFF'}\n"
        f"üì¶ ÿßŸÑŸÖÿ±ŸÉÿ≤: {pos_line}"
    )

async def fchart(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    sym = OPEN.symbol if OPEN else CURRENT
    df, _ = await _fetch_1m(sym)
    if df is None or df.empty:
        return await update.message.reply_text("ŸÑÿß ÿ™ÿ™ŸàŸÅÿ± ÿ®ŸäÿßŸÜÿßÿ™ ŸÉÿßŸÅŸäÿ© ŸÑŸÑÿ¥ÿßÿ±ÿ™.")
    last = float(df['Close'].iloc[-1])
    # ÿ£ŸáÿØÿßŸÅ ÿ™ŸÇÿ±Ÿäÿ®Ÿäÿ© ŸÑŸÑÿπÿ±ÿ∂ ŸÅŸÇÿ∑
    targets = [last*(1+FUT_TP), last*(1+FUT_TP*1.5), last*(1+FUT_TP*2.0)]
    stop = last*(1-FUT_SL)
    df_h = df.resample("60T").agg({"Open":"first","High":"max","Low":"min","Close":"last","Volume":"sum"}).dropna()
    img = plot_hourly_with_targets(df_h, targets, stop, title=f"{sym} Futures H1 ‚Äî Targets")
    await update.message.reply_photo(photo=img, caption=f"{sym} ‚Äî Binance Futures")

async def fbest(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    global LAST_BEST
    try:
        if not LAST_BEST:
            LAST_BEST = fut_best_symbols(fbr, min_qv_usd=FUT_MIN_QVOL, limit=20)[:5]
        await update.message.reply_text(fut_format(LAST_BEST, CURRENT))
    except Exception as e:
        await update.message.reply_text(f"‚ö†Ô∏è ÿ™ÿπÿ∞ÿ± ÿ¨ŸÑÿ® ÿßŸÑŸÖÿ±ÿ¥ÿ≠ŸäŸÜ: {e}")

async def fpositions(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    try:
        risks = fbr.get_position_risk(None)
        lines = ["ÿßŸÑŸÖÿ±ÿßŸÉÿ≤ ÿßŸÑŸÖŸÅÿ™Ÿàÿ≠ÿ©:"]
        has = False
        for p in risks:
            amt = float(p.get("positionAmt", "0"))
            if abs(amt) > 0:
                has = True
                sym = p.get("symbol")
                entry = float(p.get("entryPrice", "0"))
                upnl = float(p.get("unRealizedProfit", "0"))
                lev = p.get("leverage")
                side = "LONG" if amt > 0 else "SHORT"
                lines.append(f"- {sym} {side} qty={amt:.6f} | entry={entry:.6f} | uPnL={upnl:.2f} | x{lev}")
        if not has:
            lines.append("ŸÑÿß ŸäŸàÿ¨ÿØ.")
        await update.message.reply_text("\n".join(lines))
    except Exception as e:
        await update.message.reply_text(f"‚ö†Ô∏è ÿ™ÿπÿ∞ÿ± ŸÇÿ±ÿßÿ°ÿ© ÿßŸÑŸÖÿ±ÿßŸÉÿ≤: {e}")

async def fclose(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    sym = OPEN.symbol if OPEN else CURRENT
    try:
        fbr.close_all_for_symbol(sym)
        await update.message.reply_text(f"üßπ ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿ£ŸÖÿ± ÿ•ÿ∫ŸÑÿßŸÇ {sym} (reduceOnly).")
    except Exception as e:
        await update.message.reply_text(f"‚ö†Ô∏è ŸÅÿ¥ŸÑ ÿßŸÑÿ•ÿ∫ŸÑÿßŸÇ: {e}")

async def fautoscan(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    global FUT_AUTOSCAN
    text = (update.message.text or "").lower()
    if " on" in text:
        FUT_AUTOSCAN = True
    elif " off" in text:
        FUT_AUTOSCAN = False
    await update.message.reply_text(f"üîé Futures AutoScan: {'ON' if FUT_AUTOSCAN else 'OFF'} (ŸÉŸÑ {FUT_SCAN_MIN} ÿØŸÇŸäŸÇÿ©)")

async def flev(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    lines = [f"ÿßŸÑÿ±ÿßŸÅÿπÿ© ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿäÿ©: x{FUT_DEFAULT_LEV}", "ÿÆÿ±Ÿäÿ∑ÿ© ÿßŸÑÿ±ÿßŸÅÿπÿ© ŸÑŸÉŸÑ ÿ±ŸÖÿ≤:"]
    if not LEV_MAP:
        lines.append("(ŸÅÿßÿ±ÿ∫ÿ©)")
    else:
        for k, v in sorted(LEV_MAP.items()):
            lines.append(f"- {k}: x{v}")
    await update.message.reply_text("\n".join(lines))

async def fsetlev(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    if not _is_admin(update): return await update.message.reply_text("üö´ ŸÑŸÑÿ£ÿØŸÖŸÜ ŸÅŸÇÿ∑.")
    parts = (update.message.text or "").split()
    if len(parts) != 3:
        return await update.message.reply_text("ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ: /fsetlev <SYMBOL> <X>\nŸÖÿ´ÿßŸÑ: /fsetlev BTCUSDT 20")
    sym = parts[1].upper().strip()
    try:
        x = int(parts[2])
        if x < 1 or x > 125: raise ValueError()
    except Exception:
        return await update.message.reply_text("ŸÇŸäŸÖÿ© ÿßŸÑÿ±ÿßŸÅÿπÿ© ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©. ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠ 1..125")
    LEV_MAP[sym] = x
    _save_lev(LEV_MAP)
    await update.message.reply_text(f"ÿ™ŸÖ ÿ∂ÿ®ÿ∑ ÿ±ÿßŸÅÿπÿ© {sym} ÿ•ŸÑŸâ x{x} (Ÿàÿ≠ŸÅÿ∏Ÿáÿß).")

def main():
    token = CFG["TELEGRAM_TOKEN"]
    if not token:
        raise SystemExit("ÿ∂ÿπ TELEGRAM_BOT_TOKEN ŸÅŸä .env")
    app = Application.builder().token(token).build()

    app.add_handler(CommandHandler("fstart", fstart))
    app.add_handler(CommandHandler("fgo", fgo))
    app.add_handler(CommandHandler("fstop", fstop))
    app.add_handler(CommandHandler("fstatus", fstatus))
    app.add_handler(CommandHandler("fchart", fchart))
    app.add_handler(CommandHandler("fbest", fbest))
    app.add_handler(CommandHandler("fpositions", fpositions))
    app.add_handler(CommandHandler("fclose", fclose))
    app.add_handler(CommandHandler("fautoscan", fautoscan))
    app.add_handler(CommandHandler("flev", flev))
    app.add_handler(CommandHandler("fsetlev", fsetlev))

    if app.job_queue:
        app.job_queue.run_repeating(autoscan_tick, interval=FUT_SCAN_MIN*60, first=5)
        app.job_queue.run_repeating(trade_tick, interval=5, first=10)
    else:
        print('‚ö†Ô∏è JobQueue ÿ∫Ÿäÿ± ŸÖŸÅÿπŸëŸÑ. ÿ´ÿ®Ÿëÿ™: pip install "python-telegram-bot[job-queue]==21.4"')

    app.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main()
